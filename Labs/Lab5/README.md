# Labs_java

Лабораторна 5 Контрольні питання
### 1. Порівняння методів сортування: бульбашкою, вибором і вставкою

**Сортування бульбашкою (Bubble Sort):**  
- **Переваги:**
  - Простота реалізації.
  - Легко адаптується для виявлення частково відсортованих масивів (завдяки прапорцю, який зупиняє виконання, якщо під час проходу елементи не змінюються).
- **Недоліки:**
  - Повільне виконання при великих обсягах даних.
  - Велика кількість порівнянь і перестановок.

**Сортування вибором (Selection Sort):**  
- **Переваги:**
  - Простота реалізації.
  - Мінімальна кількість перестановок (на кожному етапі лише одна).
- **Недоліки:**
  - Велика кількість порівнянь незалежно від ступеня впорядкованості даних.
  - Повільний на практиці, особливо для великих обсягів даних.

**Сортування вставкою (Insertion Sort):**  
- **Переваги:**
  - Ефективний для частково відсортованих масивів.
  - Легко адаптується до динамічних наборів даних.
- **Недоліки:**
  - Не оптимальний для великих обсягів даних.
  - Повільне виконання для зворотно впорядкованих масивів.

---

### 2. Оцінка алгоритмів за критеріями

### 2. Оцінка методів за критеріями

**Сортування бульбашкою (Bubble Sort):**  
- **Час роботи:** У гіршому випадку \( O(n^2) \), коли масив відсортований у зворотному порядку. У найкращому випадку \( O(n) \), якщо масив уже відсортований.  
- **Потреби у додатковій пам’яті:** Не потребує додаткової пам’яті, \( O(1) \).  
- **Стабільність:** Стабільний, оскільки не змінює порядок елементів із однаковими значеннями.

**Сортування вибором (Selection Sort):**  
- **Час роботи:** Завжди \( O(n^2) \), незалежно від початкового стану масиву, оскільки алгоритм виконує однакову кількість порівнянь.  
- **Потреби у додатковій пам’яті:** Не потребує додаткової пам’яті, \( O(1) \).  
- **Стабільність:** Нестабільний, оскільки може змінювати порядок елементів із однаковими значеннями.

**Сортування вставкою (Insertion Sort):**  
- **Час роботи:** У гіршому випадку \( O(n^2) \), коли масив відсортований у зворотному порядку. У найкращому випадку \( O(n) \), якщо масив уже майже відсортований.  
- **Потреби у додатковій пам’яті:** Не потребує додаткової пам’яті, \( O(1) \).  
- **Стабільність:** Стабільний, оскільки не змінює порядок елементів із однаковими значеннями.

**Додаткові критерії для оцінки:**  
- Простота реалізації.  
- Адаптивність до різних ступенів впорядкованості даних.  
- Кількість порівнянь і обмінів елементів.  
- Можливість роботи з потоковими даними (для вставки це зручно).

### 3. Найкращий та найгірший випадки для роботи алгоритмів

- **Bubble Sort:**  
  - **Найкращий випадок:** Масив вже відсортований (\( O(n) \)).  
  - **Найгірший випадок:** Масив відсортований у зворотному порядку (\( O(n^2) \)).  

- **Selection Sort:**  
  - **Найкращий випадок:** Не залежить від упорядкованості, завжди \( O(n^2) \).  
  - **Найгірший випадок:** Також \( O(n^2) \).  

- **Insertion Sort:**  
  - **Найкращий випадок:** Частково відсортований масив (\( O(n) \)).  
  - **Найгірший випадок:** Масив відсортований у зворотному порядку (\( O(n^2) \)).  

**Найкращий результат для частково відсортованого масиву:** Сортування вставкою.  
**Найгірший результат для масиву, відсортованого у зворотному порядку:** Bubble Sort і Insertion Sort.

---

### 4. Що означають позначення \( O(1) \), \( O(n) \), \( O(n^2) \)?

Позначення \( O(f(n)) \) — це **асимптотична складність**, яка описує, як час виконання алгоритму змінюється в залежності від розміру вхідних даних \( n \):  
- O(1): Константна складність. Час виконання не залежить від розміру даних.  
- O(n): Лінійна складність. Час виконання пропорційний розміру даних.  
- O(n^2): Квадратична складність. Час виконання зростає пропорційно квадрату розміру даних.  

Ці оцінки дозволяють вибрати алгоритм, який працює ефективніше для певних задач.

